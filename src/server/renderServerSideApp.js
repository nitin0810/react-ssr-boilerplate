import React from 'react';
import ReactDOMServer from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import Helmet from 'react-helmet';
import path from 'path';

import { getAppEnv } from '../../config/env';
import { ChunkExtractor, ChunkExtractorManager } from '@loadable/server';

// import chalk from 'chalk';

import App from '../client/App.jsx';

const env = getAppEnv();
const { NODE_ENV } = env.raw;



export const renderServerSideApp = (req, res) => {
  const context = { data: {}, head: [] };
  collectRequiredDataPromisesInContext(context, req);
  // console.warn(chalk.green('collected data : ', JSON.stringify(context.data)));
  // at this point we have required promises in context.data
  const keys = Object.keys(context.data);
  const promises = keys.map(k => context.data[k]);
  fetchRequiredData(promises)
    .then(data => {
      data.forEach((d, i) => context.data[keys[i]] = d);
      renderApp(req, res, context);
    })
    .catch(e => {
      // if there was no promise to resolve or some error occured while resolving promises
      // just send the basic html without any data
      context.data = null; // clear the context.data object , NOTE : handle the case of context.data  being null in your components
      renderApp(req, res, context);
    });
};

const giveChunkExtractor = () => {
  // This is the stats file generated by webpack loadable plugin
  const statsFile = path.resolve('./build/loadable-stats.json')
  // create an extractor from the statsFile
  // this extractor will collect the information about which JS chunks and CSS chunks should be sent within html
  return new ChunkExtractor({ statsFile });
}

const collectRequiredDataPromisesInContext = (context, req) => {
  // do a first pass to fill the promises list in context.data
  // markup returned here is of no use as there will be anyway  a second pass executed later

  const extractor = giveChunkExtractor();

  ReactDOMServer.renderToString(
    <ChunkExtractorManager extractor={extractor}>
      <StaticRouter location={req.url} context={context}>
        <App />
      </StaticRouter>
    </ChunkExtractorManager>
  );
};

const fetchRequiredData = async (promises) => {

  if (!promises.length) {
    return Promise.reject(null);
  }
   return await Promise.all(promises);
}

function renderApp(req, res, context) {

  const extractor = giveChunkExtractor();

  const markup = ReactDOMServer.renderToString(
    <ChunkExtractorManager extractor={extractor}>
      <StaticRouter location={req.url} context={context}>
        <App />
      </StaticRouter>
    </ChunkExtractorManager>
  );

  if (context.url) {
    res.redirect(context.url);
  } else {
    // now finally prepare the full HTML page and send it
    giveFullHtml({
      helmet: Helmet.renderStatic(),
      serverData: context.data,
      markup,
      extractor
    }).then((fullMarkup) => {
      res.status(200).send(fullMarkup);
    });

  }
}

export const giveFullHtml = async ({ helmet, serverData, markup, extractor }) => {
  const htmlAttrs = helmet.htmlAttributes.toString();
  const bodyAttrs = helmet.bodyAttributes.toString();

  // do not send link tags with preload or prefetch, they don't make any difference here as corresponding script tags will be sent
  // const linkTags = extractor.getLinkTags();

  // collect your script tags (bundles and chunks for the requested page)
  const scriptTags = extractor.getScriptTags(); // or extractor.getScriptElements();

  // collect your style tags (if you use "mini-css-extract-plugin")
  // style tags are only available in production build as in development build css is included within JS chunks
  // hence no seperate .css files are available in development
  let styleTags = '', inlineStyleTags = '';

  if (NODE_ENV === 'production') {
    styleTags = extractor.getStyleTags()
    try {
      // for SSR, include the .css files content in the <style> tag within the html reponse 
      // it is done so that first page appears styles even in very first frame, otherwise page will remain unstyles untill the css files are downloaded 
      inlineStyleTags = await extractor.getInlineStyleTags();
    } catch (e) { }
  }

  // console.log('LINK TAGS : ',linkTags);
  // console.log('STYLE TAGS : ', styleTags);
  // console.log('SCRIPT TAGS : ', scriptTags);
  // window.process = ${env.forIndexHtml};

  return `
    <!doctype html>
  
    <html lang="en" ${htmlAttrs}>
      <head>
        ${helmet.title.toString()}
        ${helmet.meta.toString()}
    
        <!-- LINK TAGS WITH PRELOAD AND PREFETCH : removed-->

        <!-- INLINE STYLE TAGS : ONLY AVAILABLE IN PRODUCTION -->
        ${inlineStyleTags}
        <!-- LINK STYLE TAGS : ONLY AVAILABLE IN PRODUCTION  -->
        ${styleTags}
      </head>
      <body ${bodyAttrs}>
      <noscript>You need to enable JavaScript to run this app.</noscript>
        <div id="root">${markup}</div>

        <!-- SCRIPT TAGS-->
        ${scriptTags}
        <script>
          window.__INITIAL_DATA__ = ${JSON.stringify(serverData)}
        </script>
      </body>
    </html>
  `;
};
